buildscript {
	ext {
		springBootVersion = '1.4.2.RELEASE'
	}
	repositories {
		mavenCentral()
	}
	dependencies {
		classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
	}
}

apply plugin: 'java'
apply plugin: 'groovy'
apply plugin: 'eclipse'
apply plugin: 'org.springframework.boot'

jar {
	baseName = 'tntserver'
	version = '1.0.0'
}
sourceCompatibility = 1.8
targetCompatibility = 1.8

repositories {
	mavenCentral()
}


dependencies {
	compile('org.springframework.boot:spring-boot-starter-data-neo4j')
	compile('org.springframework.boot:spring-boot-starter-web')
	compile('org.springframework.boot:spring-boot-starter-actuator')
	compile('org.springframework.boot:spring-boot-actuator-docs')
	testCompile('org.springframework.boot:spring-boot-starter-test')
	testCompile('org.spockframework:spock-core:1.0-groovy-2.4')
	testCompile("org.spockframework:spock-spring:1.0-groovy-2.4")
	testCompile("org.codehaus.groovy.modules.http-builder:http-builder:0.7.1")
	testCompile("cglib:cglib:3.1")
}

sourceSets {
	integrationSource {
		java { srcDirs = ['src/integration/java'] }
		groovy { srcDirs = ['src/integration/java'] }
		compileClasspath += sourceSets.test.compileClasspath
		runtimeClasspath += sourceSets.test.runtimeClasspath
	}
}

test {
	testLogging {
		afterSuite { desc, result ->
			if (!desc.parent) {
				println "Test result: ${result.resultType} (total ${result.testCount} tests, ${result.successfulTestCount} succeeded, ${result.failedTestCount} failed, ${result.skippedTestCount} skipped)"
			}
		}
	}
}

task runIntegrationTest(type: Test, dependsOn: assemble) {
	description = 'Run integration tests'
	outputs.upToDateWhen { false }
	doFirst() {
		def count = 1
		tasks.startDockerForIntegration.execute()
		60.times {
			if (!['curl', 'http://localhost:8080/info'].execute().text) {
				println('waiting for applicaiton start ...' + count)
				sleep(1000)
				count++
			}
		}
	}
	testClassesDir = sourceSets.integrationSource.output.classesDir
	classpath = sourceSets.integrationSource.runtimeClasspath
	reports.junitXml.destination = 'build/test-results'
	reports.html.destination = 'build/reports/integrationTests'
	afterSuite { desc, result ->
		if (!desc.parent) {
			println "Integration tests result: ${result.resultType} (total ${result.testCount} tests, ${result.successfulTestCount} succeeded, ${result.failedTestCount} failed, ${result.skippedTestCount} skipped)"
			tasks.stopDockerForIntegration.execute()
		}
	}
}

task startDockerForIntegration(dependsOn: assemble) {
	doLast {
		exec {
			commandLine 'cp', jar.archivePath, 'build/tntserver.jar'
		}
		exec {
			commandLine 'docker-compose', '-f', 'integration-docker.yml', 'up', '-d'
		}
	}
}

task stopDockerForIntegration() {
	doLast {
		exec {
			commandLine 'docker-compose', '-f', 'integration-docker.yml', 'stop'
			ignoreExitValue true
		}
		exec {
			commandLine 'docker-compose', '-f', 'integration-docker.yml', 'rm', '-f'
			ignoreExitValue true
		}
		exec {
			commandLine 'rm', '-f', 'build/tntserver.jar'
			ignoreExitValue true
		}
	}
}

task startDockerForDebugging() {
	doLast {
		exec {
			commandLine 'docker-compose', '-f', 'debugging-docker.yml', 'up', '-d'
		}
	}
}

task stopDockerForDebugging() {
	doLast {
		exec {
			commandLine 'docker-compose', '-f', 'debugging-docker.yml', 'stop'
			ignoreExitValue true
		}
		exec {
			commandLine 'docker-compose', '-f', 'debugging-docker.yml', 'rm', '-f'
			ignoreExitValue true
		}
	}
}


test.finalizedBy(runIntegrationTest)